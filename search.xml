<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS类型检测]]></title>
    <url>%2F2018%2F04%2F01%2Ftype20180401%2F</url>
    <content type="text"><![CDATA[类型首先贴下ECMA定义的类型 基本数据类型： Number（数字） String（字符串） Boolean（布尔） Symbol（符号）（第六版新增） Null（空） Undefined（未定义） 复杂数据类型: Object Object 包含： Function（函数） Array（数组） Date（日期） RegExp（正则表达式） Error (错误) typeoftypeof 是一元运算符，返回时数据的类型字符串，看代码12345678910111213141516171819202122232425262728293031let number = 1;let str = 'str';let func = function()&#123;&#125;;let arr = [];let obj = &#123;&#125;;let bool = true;let unde = undefined;let na = NaN;let sy = Symbol('test');let nu = null;console.log(typeof number); // numberconsole.log(typeof str); // stringconsole.log(typeof func); // functionconsole.log(typeof arr); // objectconsole.log(typeof obj); // objectconsole.log(typeof bool); // booleanconsole.log(typeof unde); // undefinedconsole.log(typeof na); // numberconsole.log(typeof sy); // symbolconsole.log(typeof nu); // object typeof 能静准的判断基本数据类型，却不能精准的判断引用数据类型 instanceofinstanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。就是检查是否属于某个目标的实例12345678910111213function c()&#123;&#125;function d()&#123;&#125;let cc = new c();console.log(cc instanceof c); // true 因为 Object.getPrototypeOf(o) === C.prototypeconsole.log(cc instanceof d); // falseconsole.log(cc instanceof Object); // trueconsole.log(d instanceof Object); // truec.prototype = &#123;&#125;;console.log(cc instanceof c); // false c.prototype指向了一个空对象,这个空对象不在cc的原型链上 instanceof 只能检测是否是目标的实例（处于目标的原型链上） Object.prototype.toString.call让检测对象的prototype上有Object.prototype的toString方法 1234567891011121314151617181920212223242526272829303132let number = 1;let str = 'str';let func = function()&#123;&#125;;let arr = [];let obj = &#123;&#125;;let bool = true;let unde = undefined;let na = NaN;let sy = Symbol('test');let nu = null;const toString = Object.prototype.toString;console.log(toString.call(number)); // [object Number]console.log(toString.call(str)); // [object String]console.log(toString.call(func)); // [object Function]console.log(toString.call(arr)); // [object Array]console.log(toString.call(obj)); // [object Object]console.log(toString.call(bool)); // [object Boolean]console.log(toString.call(unde)); // [object Undefined]console.log(toString.call(na)); // [object Number]console.log(toString.call(sy)); // [object Symbol]console.log(toString.call(nu)); // [object Null] 完美~ 安利一个函数检测数据类型：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function isType(val,type)&#123; return Object.prototype.toString.call(val) === `[object $&#123;type&#125;]`;&#125;;const Type = Object.defineProperties(&#123;&#125;,&#123; 'Array': &#123; enumerable: true, value: 'Array' &#125;, 'Object': &#123; enumerable: true, value: 'Object' &#125;, 'Function': &#123; enumerable: true, value: 'Function' &#125;, 'String': &#123; enumerable: true, value: 'String' &#125;, 'Number': &#123; enumerable: true, value: 'Number' &#125;, 'Boolean': &#123; enumerable: true, value: 'Boolean' &#125;, 'Symbol': &#123; enumerable: true, value: 'Symbol' &#125;, 'Undefined': &#123; enumerable: true, value: 'Undefined' &#125;, 'Null': &#123; enumerable: true, value: 'Null' &#125;&#125;);// 使用console.log(isType(number,Type.Number));console.log(isType(str,Type.String));console.log(isType(func,Type.Function));console.log(isType(arr,Type.Array));console.log(isType(obj,Type.Object));console.log(isType(bool,Type.Boolean));console.log(isType(unde,Type.Undefined));console.log(isType(sy,Type.Symbol));console.log(isType(nu,Type.Null));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>defineProperty</tag>
        <tag>Type</tag>
        <tag>call</tag>
        <tag>typeof</tag>
        <tag>instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[should.js 写法实现]]></title>
    <url>%2F2018%2F04%2F01%2Fdefind20180401%2F</url>
    <content type="text"><![CDATA[关于 should.js先上代码12345678var should = require('should');var user = &#123; name: 'tj' , pets: ['tobi', 'loki', 'jane', 'bandit']&#125;;user.should.have.property('name', 'tj'); // true 看到这样的写法是不是很酷炫，反正我当时就是，我们来一步一步实现它。 原型链首先user这个对象本身是没有should这个属性的，那就肯定是往原型链上找了，所以事先把这个属性挂载到Object.prototype上 1234567891011// 1、function tool(obj)&#123; this._obj = obj;&#125;// 2、Object.defineProperty(Object.prototype,'tool',&#123; get: function()&#123; return new tool(this); &#125;&#125;); 1、先定义一个函数，将调用对象的this当做tool函数的内部对象传入 2、在Object.prototype上定义一个名为为tool的属性，设置这个属性的get访问拦截返回通过构造函数实例化的tool 看看效果123456789const tool = require('./lib/defind');const user = &#123; a: 1, b: 'test'&#125;;console.log(user.tool); // 3、 3、打印了 tool { _obj: { a: 1, b: &#39;test&#39; } } 就是这么简单实现了这种酷炫的写法，添加一个tool的方法判断调用对象是否有该属性123tool.prototype.has = function(key)&#123; return this._obj.hasOwnProperty(key);&#125; 4、刚才在tool函数里保存的_obj现在起作用了 console一下 1234let has = user.tool.has('a');console.log(has); // truehas = user.tool.has('c');console.log(has); // false 剩下的api有兴趣的朋友自己实现吧~ 参考链接： https://github.com/tj/should.js]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>defineProperty</tag>
        <tag>Object.prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS对象属性探究]]></title>
    <url>%2F2018%2F04%2F01%2FObject20180401%2F</url>
    <content type="text"><![CDATA[对象ECMAScript 将对象的属性分为数据属性和访问器属性,属性描述符有两种主要形式：数据描述符和存取描述符,使用defineProperty可以为对象已有的属性添加特性描述：12345678910var obj = &#123; test:&quot;hello&quot;&#125;//对象已有的属性添加特性描述Object.defineProperty(obj,&quot;test&quot;,&#123; configurable:true | false, // 是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable） enumerable:true | false, // 是否可枚举 value:任意类型的值, writable:true | false // 属性的值是否可以被重写&#125;); ES5有三个操作会忽略enumerable为false的属性： for…in循环：只遍历对象自身的和继承的可枚举的属性 Object.keys()：返回对象自身的所有可枚举的属性的键名 JSON.stringify()：只串行化对象自身的可枚举的属性 Object.getOwnPropertyNames获取该对象不包括原型链所有的属性包括不可枚举的ES6新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。123456789Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;).enumerable// falseObject.prototype.propertyIsEnumerable(&apos;toString&apos;) // falseObject.getOwnPropertyDescriptor([], &apos;length&apos;).enumerable// false[].propertyIsEnumerable(&apos;length&apos;) // false toString和length属性的enumerable都是false，因此for…in不会遍历到这两个继承自原型的属性。 当使用了getter或setter方法，不允许使用writable和value这两个属性。 ES5 环境，Object.keys如果传入的参数不是一个对象，而是一个字符串，那么它会报 TypeError。在 ES6 环境，如果传入的是一个非对象参数，内部会对参数作一次强制对象转换，如果转换不成功会抛出 TypeError。12345// 在 ES5 环境Object.keys(&apos;foo&apos;); // TypeError: &quot;foo&quot; is not an object// 在 ES6 环境Object.keys(&apos;foo&apos;); // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] 参考链接： https://www.zhihu.com/question/40648241?from=profile_question_card https://www.cnblogs.com/wujie520303/p/4931384.html https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量声明之旅]]></title>
    <url>%2F2017%2F12%2F01%2Ftest%2F</url>
    <content type="text"><![CDATA[var、let、const 定义变量var 定义的变量允许变量提升（Hoisting），还涉及到 变量进行 LHS（Left Hand Side）查找123举个栗子：console.log(x); // var is upvar x = 'var is up'; 但是得注意一下，var声明的变量可以提升，但是如果是一个定义一个函数，函数表达式是不可以提升的，如下:12345678910var x = func();var func = function()&#123; return 'this is function';&#125;// 相当于下面的代码：var func;var x = func();func = function()&#123; return 'this is function';&#125; 上面那段代码会被爆出TypeError,变量func被提升了，但是后面的函数表达式没被提升，提升的func的初始化是var func = undefined,上面的操作相当于undefined(),所以就爆TypeError了; 函数声明和函数表达式声明函数声明会整体提升到当前作用域的顶端，而函数表达式声明只提升变量名，表达式并不会提升（栗子看上面👆代码），举个🌰 ：123456789101112test() // 1test2() // TypeError// 函数声明function test()&#123; console.log(1);&#125;// 函数表达式声明var test2 = function()&#123; console.log(2);&#125; 作用域var 并不是块级作用域，所以容易造成作用域污染，在全局作用域下用var定义一个变量会被挂载到global或window中,看下面这段代码：1234function test()&#123; for(var i = 0; i &lt; 3; i++)&#123;&#125; console.log(i); // 3&#125; 上面那段代码，在}外依旧能访问到 i 。let 是块级作用域，而且在全局作用域定义的变量并不会被挂载到global货window中：1234function test()&#123; for(let i = 0; i &lt; 3; i++)&#123;&#125; console.log(i); // i is defined&#125; const 是定义常量，和java的final关键字类似，但是有一点区别的是，const定义的如果的对象，则对象里面的参数值是可以改变的，const的作用是保证初始定义的变量的内存地址是不变的。123456const a = 1;a = 2; // Assignment to constant variableconst obj = &#123;&#125;;obj.a = 1;console.log(obj.a); // 1 PS: 能用const定义的就用const]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>let</tag>
        <tag>const</tag>
        <tag>var</tag>
      </tags>
  </entry>
</search>
